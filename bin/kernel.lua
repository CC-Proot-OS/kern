local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        local t = toml.decode(lookup(s,"cfg.toml").data)
        --local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                t.drvr = t.drvr
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    --srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        local t = toml.decode(lookup(s,"cfg.toml").data)
        --local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                t.drvr = t.drvr
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        local t = toml.decode(lookup(s,"cfg.toml").data)
        --local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        local t = toml.decode(lookup(s,"cfg.toml").data)
        --local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

args = {
    loglevel = 1,
    runSrv = true
}

for z, i in ipairs({ ... }) do
    local aE, aF = i:match("^([^=]+)=(.+)$")
    if aE and aF then
        if type(args[aE]) == "boolean" then
            args[aE] = aF:lower() == "true" or aF == "1"
        elseif type(args[aE]) == "number" then
            args[aE] = tonumber(aF)
        else
            args[aE] = aF
        end
    elseif aE == "silent" then
        args.loglevel = 5
    elseif aE == "quiet" then
        args.loglevel = 3
    end
end

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("Welcome to \27[96mProot\27[93mOS\27[0m")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("Welcome to \27[96mProot\27[33mOS\27[0m")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\27[96mWelcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\27[96mWelcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\27[96mWelcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\27[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\27[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x27[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x1b[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x1b[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x1b[31m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x1b[91m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\21[91m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    print("\x1B[91m Welcome to ProotOS")
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
-- Generated with sanjuuni
-- https://sanjuuni.madefor.cc
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
-- Generated with sanjuuni
-- https://sanjuuni.madefor.cc
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(%.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
-- Generated with sanjuuni
-- https://sanjuuni.madefor.cc
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        --local pth,name,ext = string.match(files[i], "(.-)([^\\]-([^\\%.]+))$")
        local name = string.gsub(files[i],"(.a)","")
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["bin.kernel"] = function(...)
local loading = {}
local oldRequire, preload, loaded = require, {}, { startup = loading }

local function require(name)
	local result = loaded[name]

	if result ~= nil then
		if result == loading then
			error("loop or previous error loading module '" .. name .. "'", 2)
		end

		return result
	end

	loaded[name] = loading
	local contents = preload[name]
	if contents then
		result = contents(name)
	elseif oldRequire then
		result = oldRequire(name)
	else
		error("cannot load '" .. name .. "'", 2)
	end

	if result == nil then result = true end
	loaded[name] = result
	return result
end
preload["toml"] = function(...)
-- TOML library for Lua/CC
-- From Phoenix libsystem serialization.toml
--
-- MIT License
--
-- Copyright (c) 2024 JackMacWindows
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.

local expect
local field

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

local toml = {}

-- From json.lua by rxi
-- MIT license

local escape_char_map = {
    [ "\\" ] = "\\",
    [ "\"" ] = "\"",
    [ "\b" ] = "b",
    [ "\f" ] = "f",
    [ "\n" ] = "n",
    [ "\r" ] = "r",
    [ "\t" ] = "t",
}

local escape_char_map_inv = { [ "/" ] = "/" }
for k, v in pairs(escape_char_map) do
    escape_char_map_inv[v] = k
end

local function create_set(...)
    local res = {}
    for i = 1, select("#", ...) do
        res[ select(i, ...) ] = true
    end
    return res
end

local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")

local function decode_error(str, idx, msg)
    local line_count = 1
    local col_count = 1
    for i = 1, idx - 1 do
        col_count = col_count + 1
        if str:sub(i, i) == "\n" then
            line_count = line_count + 1
            col_count = 1
        end
    end
    error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
    -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
    local f = math.floor
    if n <= 0x7f then
        return string.char(n)
    elseif n <= 0x7ff then
        return string.char(f(n / 64) + 192, n % 64 + 128)
    elseif n <= 0xffff then
        return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
    elseif n <= 0x10ffff then
        return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                                             f(n % 4096 / 64) + 128, n % 64 + 128)
    end
    error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
    local n1 = tonumber( s:sub(1, 4),  16 )
    local n2 = tonumber( s:sub(7, 10), 16 )
     -- Surrogate pair?
    if n2 then
        return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
    else
        return codepoint_to_utf8(n1)
    end
end


local function parse_string(str, i)
    local res = ""
    local j = i + 1
    local k = j

    while j <= #str do
        local x = str:byte(j)

        if x < 32 then
            decode_error(str, j, "control character in string")

        elseif x == 92 then -- `\`: Escape
            res = res .. str:sub(k, j - 1)
            j = j + 1
            local c = str:sub(j, j)
            if c == "u" then
                local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)
                                 or str:match("^%x%x%x%x", j + 1)
                                 or decode_error(str, j - 1, "invalid unicode escape in string")
                res = res .. parse_unicode_escape(hex)
                j = j + #hex
            else
                if not escape_chars[c] then
                    decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")
                end
                res = res .. escape_char_map_inv[c]
            end
            k = j + 1

        elseif x == 34 then -- `"`: End of string
            res = res .. str:sub(k, j - 1)
            return res, j + 1
        end

        j = j + 1
    end

    decode_error(str, i, "expected closing quote for string")
end

-- End json.lua

local keywords = {
    ["and"] = true,
    ["break"] = true,
    ["do"] = true,
    ["else"] = true,
    ["elseif"] = true,
    ["end"] = true,
    ["false"] = true,
    ["for"] = true,
    ["function"] = true,
    ["goto"] = true,
    ["if"] = true,
    ["in"] = true,
    ["local"] = true,
    ["nil"] = true,
    ["not"] = true,
    ["or"] = true,
    ["repeat"] = true,
    ["return"] = true,
    ["then"] = true,
    ["true"] = true,
    ["until"] = true,
    ["while"] = true,
}

local function lua_serialize(val, stack, opts, level)
    if stack[val] then error("Cannot serialize recursive value", 0) end
    local tt = type(val)
    if tt == "table" then
        if not next(val) then return "{}" end
        stack[val] = true
        local res = opts.minified and "{" or "{\n"
        local num = {}
        for i, v in ipairs(val) do
            if not opts.minified then res = res .. ("    "):rep(level) end
            num[i] = true
            res = res .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end
        for k, v in pairs(val) do if not num[k] then
            if not opts.minified then res = res .. ("    "):rep(level) end
            if type(k) == "string" and k:match "^[A-Za-z_][A-Za-z0-9_]*$" and not keywords[k] then res = res .. k
            else res = res .. "[" .. lua_serialize(k, stack, opts, level + 1) .. "]" end
            res = res .. (opts.minified and "=" or " = ") .. lua_serialize(v, stack, opts, level + 1) .. (opts.minified and "," or ",\n")
        end end
        if opts.minified then res = res:gsub(",$", "")
        else res = res .. ("    "):rep(level - 1) end
        stack[val] = nil
        return res .. "}"
    elseif tt == "function" and opts.allow_functions then
        local ok, dump = pcall(string.dump, val)
        if not ok then error("Cannot serialize C function", 0) end
        dump = ("%q"):format(dump):gsub("\\[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
        local ups = {n = 0}
        stack[val] = true
        for i = 1, math.huge do
            local ok, name, value = pcall(debug.getupvalue, val, i)
            if not ok or not name then break end
            ups[i] = value
            ups.n = i
        end
        local name = "=(serialized function)"
        local ok, info = pcall(debug.getinfo, val, "S")
        if ok then name = info.source or name end
        local v = ("__function(%s,%q,%s)"):format(dump, name, lua_serialize(ups, stack, opts, level + 1))
        stack[val] = nil
        return v
    elseif tt == "nil" or tt == "number" or tt == "boolean" or tt == "string" then
        return ("%q"):format(val):gsub("\\\n", "\\n"):gsub("\\?[%z\1-\31\127-\255]", function(c) return ("\\%03d"):format(string.byte(c)) end)
    else
        error("Cannot serialize type " .. tt, 0)
    end
end

local function encodeTOMLArray(arr, opts, names)
    local int, str = false, false
    for l in pairs(arr) do
        if type(l) == "number" then int = true
        elseif type(l) == "string" then str = true
        else error("key " .. table.concat(names, ".") .. "." .. tostring(l) .. " is not a string") end
    end
    local e = #names + 1
    if not int and not str then return "[]"
    elseif int and str then error("invalid entry " .. table.concat(names, ".") .. " (contains both array and dictionary values)")
    elseif int then
        local retval = "["
        for i, v in ipairs(arr) do
            if type(v) == "table" then
                names[e] = tostring(i)
                retval = retval .. (retval == "[" and "" or ", ") .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else retval = retval .. (retval == "[" and "" or ", ") .. lua_serialize(v, {}, {}, #names) end
        end
        return retval .. "]"
    else
        local res = "{"
        for k, v in pairs(arr) do
            if res ~= "{" then res = res .. ", " end
            if type(k) == "string" and k:match "^[A-Za-z0-9_%-]+$" then res = res .. k
            else res = res .. lua_serialize(k, {}, {}, #names) end
            if type(v) == "table" then
                names[e] = k
                res = res .. " = " .. encodeTOMLArray(v, opts, names)
                names[e] = nil
            else res = res .. " = " .. lua_serialize(v, {}, {}, #names) end
        end
        return res .. "}"
    end
end

local function encodeTOML(tbl, opts, names)
    local retval = ""
    local indent = opts.indent == false and "" or ("    "):rep(#names)
    if #names > 0 then retval = ("%s[%s]\n"):format(("    "):rep(#names - 1), table.concat(names, ".")) end
    local tbls, arrs = {}, {}
    local e = #names + 1
    for k, v in pairs(tbl) do
        assert(type(k) == "string", "key " .. table.concat(names, ".") .. "." .. tostring(k) .. " is not a string")
        local key = k:match("^[A-Za-z0-9_%-]+$") and k or lua_serialize(k, {}, {}, 1)
        local t = type(v)
        if t == "table" then
            local int, str, tab = false, false, true
            for l, w in pairs(v) do
                if type(l) == "number" then int = true
                elseif type(l) == "string" then str = true
                else error("key " .. table.concat(names, ".") .. "." .. tostring(k) .. "." .. tostring(l) .. " is not a string") end
                if type(w) ~= "table" then tab = false
                else for m in pairs(w) do if type(m) ~= "string" then tab = false break end end end
            end
            if not int and not str then retval = retval .. indent .. key .. " = []\n"
            elseif int and str then error("invalid entry " .. table.concat(names, ".") .. "." .. tostring(k) .. " (contains both array and dictionary values)")
            elseif int then
                if tab then
                    arrs[k] = v
                else
                    names[e] = k
                    retval = retval .. indent .. key .. " = " .. encodeTOMLArray(v, opts, names)
                    names[e] = nil
                end
            else tbls[k] = v end
        else retval = retval .. indent .. key .. " = " .. lua_serialize(v, {}, {}, #names) .. "\n" end
    end
    for k, arr in pairs(arrs) do
        names[e] = k
        for _, v in ipairs(arr) do
            retval = retval .. ("%s[[%s]]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
        end
    end
    for k, v in pairs(tbls) do
        names[e] = k
        retval = retval .. ("%s[%s]\n"):format(indent, table.concat(names, ".")) .. encodeTOML(v, opts, names) .. "\n"
    end
    names[e] = nil
    return retval
end

--- Encodes a table into TOML format. This table must only have integer or
-- string keys in itself and each subtable, and cannot mix strings and ints.
-- @tparam table tbl The table to encode
-- @tparam[opt] {indent=boolean} opts Any options to specify while encoding
-- @treturn string The encoded TOML data
function toml.encode(tbl, opts)
    expect(1, tbl, "table")
    expect(2, opts, "table", "nil")
    return encodeTOML(tbl, opts or {}, {})
end

local function traverse(tab, name, pos, ln, wantlast)
    local last, nm
    while pos < #name do
        if pos > 1 then
            pos = name:match("^%s*()", pos)
            if wantlast and name:sub(pos, pos) == "=" then return last, nm, pos + 1 end
            if name:sub(pos, pos) ~= "." then error("Expected . on line " .. ln, 3) end
            pos = name:match("^%s*()", pos + 1)
        end
        local key
        if name:match('^"', pos) then key, pos = parse_string(name, pos + 1)
        elseif name:match("^'", pos) then key, pos = name:match("'([^']*)'()", pos)
        else key, pos = name:match("^([A-Za-z0-9_%-]+)()", pos) end
        if not key then error("Invalid key name on line " .. ln, 3) end
        last, nm = tab, key
        if not tab[key] then tab[key] = {} end
        tab = tab[key]
    end
    if wantlast then error("Expected = on line " .. ln, 3) end
    return tab
end

local function next_token(line, pos, ln)
    pos = line:match("^%s*()", pos)
    while pos > #line or line:sub(pos, pos) == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
    end
    return line, pos, ln
end

local function toml_assign(tab, key, line, pos, ln)
    local op = line:sub(pos, pos)
    while op == "#" do
        line = coroutine.yield()
        ln = ln + 1
        pos = line:match "^%s*()"
        op = line:sub(pos, pos)
    end
    if op == "[" then
        local retval = {}
        local i = 1
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "]" then break end
            line, pos, ln = toml_assign(retval, i, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "]" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
            i = i + 1
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "{" then
        local retval = {}
        line, pos, ln = next_token(line, pos + 1, ln)
        while true do
            op = line:sub(pos, pos)
            if op == "}" then break end
            local t, k
            t, k, pos = traverse(retval, line, pos, ln, true)
            line, pos, ln = next_token(line, pos, ln)
            line, pos, ln = toml_assign(t, k, line, pos, ln)
            line, pos, ln = next_token(line, pos, ln)
            op = line:sub(pos, pos)
            if op == "}" then break end
            if op ~= "," then error("Expected , on line " .. ln, 0) end
            line, pos, ln = next_token(line, pos + 1, ln)
        end
        tab[key] = retval
        return line, pos + 1, ln
    elseif op == "'" then
        if line:match("^'''", pos) then
            pos = pos + 3
            local str = ""
            while not line:find("'''", pos) do
                if not (str == "" and pos == #line) then
                    str = str .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            str = str .. line:sub(pos, line:find("'''", pos) - 1)
            pos = line:match("'''()", pos)
            tab[key] = str
            return line, pos, ln
        else
            local str, pos = line:match("^'([^']*)'()", pos)
            if not str then error("Invalid literal string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif op == '"' then
        if line:match('^"""', pos) then
            local s = ""
            while not line:find('"""', pos) do
                if not (s == "" and pos == #line) then
                    s = s .. line:sub(pos) .. "\n"
                end
                line = coroutine.yield()
                ln, pos = ln + 1, 1
            end
            s = s .. line:sub(pos, line:find('"""', pos) - 1)
            s = s:gsub("\\\r?\n", ""):gsub('"', '\\"') .. '"'
            tab[key] = parse_string(s, 1)
            pos = line:match('"""()', pos)
            return line, pos, ln
        else
            local str, pos = parse_string(line, pos)
            if not str then error("Invalid string on line " .. ln, 0) end
            tab[key] = str
            return line, pos, ln
        end
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d", pos) then
        local y, M, d, h, m, s, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = tonumber(h),
            min = tonumber(m),
            sec = tonumber(s)
        }
        local time = os.time(date)
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        local c = line:sub(pos, pos)
        if c == "+" or c == "-" then
            local oh, om
            oh, om, pos = line:match("^[%+%-](%d%d):(%d%d)()", pos)
            if not oh then error("Invalid date format on line " .. ln, 0) end
            local offset = tonumber(oh) * 3600 + tonumber(om) * 60
            if c == "-" then offset = -offset end
            time = time + offset
        elseif c == "Z" then pos = pos + 1 end
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%d%d%-%d%d%-%d%d", pos) then
        local y, M, d, pos = line:match("^(%d%d%d%d)%-(%d%d)%-(%d%d)()", pos)
        local date = {
            year = tonumber(y),
            month = tonumber(M),
            day = tonumber(d),
            hour = 0,
            min = 0,
            sec = 0
        }
        local time = os.time(date)
        tab[key] = time
        return line, pos, ln
    elseif line:match("^%d%d%:%d%d:%d%d", pos) then
        local h, m, s, pos = line:match("^(%d%d):(%d%d):(%d%d)()", pos)
        local time = h * 3600 + m * 60 * s
        if line:match("^%.%d+", pos) then
            local ss
            ss, pos = line:match("(%.%d+)()", pos)
            time = time + tonumber("0" .. ss)
        end
        tab[key] = time
        return line, pos, ln
    elseif op:match "%d" or op == "+" or op == "-" then
        if line:match("^%+inf", pos) then tab[key] = math.huge return line, pos + 4, ln
        elseif line:match("^%-inf", pos) then tab[key] = -math.huge return line, pos + 4, ln
        elseif line:match("^%+nan", pos) then tab[key] = -(0/0) return line, pos + 4, ln
        elseif line:match("^%-nan", pos) then tab[key] = 0/0 return line, pos + 4, ln
        elseif line:match("^[%+%-]?0o", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0o([0-7_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 8)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        elseif line:match ("^[%+%-]?0b", pos) then
            local sign, num, pos = line:match("^([%+%-]?)0b([01_]+)()", pos):gsub("_", "")
            if not num then error("Invalid number on line " .. ln, 0) end
            num = tonumber(num, 2)
            if not num then error("Invalid number on line " .. ln, 0) end
            if sign == "-" then num = -num end
            tab[key] = num
            return line, pos, ln
        else
            local num, pos = line:match("^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()", pos)
            num = num:gsub("_", "")
            num = tonumber(num)
            if not num then error("Invalid number on line " .. ln, 0) end
            tab[key] = num
            return line, pos, ln
        end
    elseif line:match("^true", pos) then tab[key] = true return line, pos + 4, ln
    elseif line:match("^false", pos) then tab[key] = false return line, pos + 5, ln
    elseif line:match("^nil", pos) then tab[key] = nil return line, pos + 3, ln -- extension
    elseif line:match("^inf", pos) then tab[key] = math.huge return line, pos + 3, ln
    elseif line:match("^nan", pos) then tab[key] = -(0/0) return line, pos + 3, ln
    else error("Unexpected " .. op .. " on line " .. ln, 0) end
end

--- Parses TOML data into a table.
-- @tparam string str The TOML data to decode
-- @tparam[opt] table opts Options (none available in this version)
-- @treturn table A table representing the TOML data
function toml.decode(str, opts)
    expect(1, str, "string")
    opts = expect(2, opts, "table", "nil") or {}
    local retval = {}
    local current = retval
    local ln = 1
    local coro
    for line in str:gmatch "([^\r\n]*)\r?\n" do
        if coro then
            -- continuation of multi-line value
            local ok, err = coroutine.resume(coro, line)
            if not ok then error(err, 3) end
            if coroutine.status(coro) == "dead" then coro = nil end
        else
            line = line:gsub("^%s+", "")
            if line:match "^#" or line == "" then -- nothing
            elseif line:match "^%[%[" then
                local tag = line:match "^%[(%b[])%]"
                if not tag then error("Expected ]] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
                current[#current+1] = {}
                current = current[#current]
            elseif line:match "^%[" then
                local tag = line:match "^%b[]"
                if not tag then error("Expected ] on line " .. ln, 2) end
                current = traverse(retval, tag:sub(2, -2), 1, ln)
            else
                local last, key, pos = traverse(current, line, 1, ln, true)
                pos = line:match("^%s*()", pos)
                if not pos then error("Expected value on line " .. ln, 2) end
                coro = coroutine.create(toml_assign)
                local ok, err = coroutine.resume(coro, last, key, line, pos, ln)
                if not ok then error(err, 3) end
                if coroutine.status(coro) == "dead" then coro = nil end
            end
        end
        ln = ln + 1
    end
    if coro then error("Unfinished value at end of file", 2) end
    return retval
end

return toml
end
preload["theme"] = function(...)
term.setPaletteColor(2, 0xD06018)
term.setPaletteColor(16, 0xffa300)
end
preload["taskmaster"] = function(...)
-- Taskmaster: A simple and highly flexible task runner/coroutine manager for ComputerCraft
-- Supports adding/removing tasks, early exits for tasks, event white/blacklists, automatic
-- terminal redirection, task pausing, promises, and more.
-- Made by JackMacWindows
-- Licensed under CC0 in the public domain

--[[
    Examples:

    - Run three functions in parallel, and wait for any to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAny()
    
    - Run three functions in parallel, and wait for all to exit.

        require("taskmaster")(
            func1, func2, func3
        ):waitForAll()

    - Builder-style creation of three event listeners for keyboard events.

        require("taskmaster")()
            :eventListener("key", function(ev, key) print("Key:", keys.getName(key)) end)
            :eventListener("key_up", function(ev, key) print("Key up:", keys.getName(key)) end)
            :eventListener("char", function(ev, char) print("Character:", char) end)
            :run()

    - Create a loop with two background tasks (which don't receive user interaction events) and one foreground task.
      The foreground task may exit itself if a specific character is pressed.

        local loop = require("taskmaster")()
        loop:setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
        loop:addTask(bgFunc)
        loop:addTimer(2, pollingFunction)

        local function fgFunc(task)
            while true do
                local event, p1 = os.pullEvent()
                if event == "char" and p1 == "q" then
                    task:remove()
                end
            end
        end

        local task = loop:addTask(fgFunc)
        task:setEventBlacklist {}
        task:setPriority(10)

        loop:run()
    
    - Fetch a remote JSON resource in parallel using promises.

        local loop = require("taskmaster")()

        local function main()
            loop.Promise.fetch("https://httpbin.org/headers")
                :next(function(handle) return handle.json() end)
                :next(function(data) print(data.headers["User-Agent"]) end)
                :catch(printError)
        end

        loop:task(main):run()
]]

local expect = require "cc.expect"

---@class Task
---@field master Taskmaster The event loop for the task
local Task = {}
local Task_mt = {__name = "Task", __index = Task}

--- Pauses the task, preventing it from running. This will yield if the task calls this method on itself.
function Task:pause()
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Unpauses the task if it was previously paused by @{Task.pause}.
function Task:unpause()
    self.paused = false
end

--- Removes the task from the run loop, as if it returned. This will yield if the task calls this method on itself.
function Task:remove()
    self.master.dead[#self.master.dead+1] = self
    self.paused = true
    if self.master.currentTask == self then coroutine.yield() end
end

--- Sets the priority of the task. This determines the order tasks are run in.
---@param priority number The priority of the task (0 is the default)
function Task:setPriority(priority)
    expect(1, priority, "number")
    self.priority = priority
    self.master.shouldSort = true
end

--- Sets a blacklist for events to send to this task.
---@param list? string[] A list of events to not send to this task
function Task:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to this task.
---@param list? string[] A list of events to send to this task (others are discarded)
function Task:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets an error handler for a task.
---@param errh? fun(err: any, task: Task) A function to call if the task throws an error
function Task:setErrorHandler(errh)
    self.errh = expect(1, errh, "function", "nil")
end

---@class Promise
---@field private task Task
---@field private resolve fun(...: any)|nil
---@field private reject fun(err: any)|nil
---@field private final fun()|nil
local Promise = {}
local Promise_mt = {__name = "Promise", __index = Promise}

--- Creates a new Promise on the selected run loop.
---@param loop Taskmaster The loop to create the promise on
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function Promise:new(loop, fn)
    expect(1, loop, "table")
    expect(2, fn, "function")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        local ok, err = pcall(fn,
            function(...) if obj.resolve then return obj.resolve(...) end end,
            function(err)
                while obj do
                    if obj.reject then return obj.reject(err) end
                    obj = obj.next_promise
                end
            end
        )
        if not ok and obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:all(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(function(...)
                count = count + 1
                if count == #list then resolve(...) end
            end, reject)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:any(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        local count = 0
        for _, v in ipairs(list) do
            v:next(resolve, function(err)
                count = count + 1
                if count == #list then reject(err) end
            end)
        end
    end)
end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param loop Taskmaster The loop to create the promise on
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function Promise:race(loop, list)
    expect(1, loop, "table")
    expect(2, list, "table")
    return Promise:new(loop, function(resolve, reject)
        for _, v in ipairs(list) do v:next(resolve, reject) end
    end)
end

--- Creates a new Promise that immediately resolves to a value.
---@param loop Taskmaster The loop to create the promise on
---@param val any The value to resolve to
---@return Promise promise The new promise
function Promise:_resolve(loop, val)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.resolve then obj.resolve(val) end
    end)
    return obj
end

--- Creates a new Promise that immediately rejects with an error.
---@param loop Taskmaster The loop to create the promise on
---@param err any The value to resolve to
---@return Promise promise The new promise
function Promise:_reject(loop, err)
    expect(1, loop, "table")
    local obj = setmetatable({}, Promise_mt)
    obj.task = loop:addTask(function()
        if obj.reject then obj.reject(err) end
    end)
    return obj
end

--- Adds a function to call when the promise resolves.
---@param fn fun(...: any): Promise|nil The function to call
---@param err? fun(err: any) A function to catch errors
---@return Promise next The next promise in the chain
function Promise:next(fn, err)
    expect(1, fn, "function")
    expect(2, err, "function", "nil")
    self.resolve = function(...)
        self.resolve = nil
        local res = fn(...)
        if self.next_promise then
            if type(res) == "table" and getmetatable(res) == Promise_mt then
                for k, v in pairs(self.next_promise) do res[k] = v end
                self.next_promise = res
            else
                self.next_promise.resolve(res)
            end
        end
        if self.final then self.final() end
    end
    if err then self.reject = function(v) self.reject = nil err(v) if self.final then self.final() end end end
    self.next_promise = setmetatable({}, Promise_mt)
    return self.next_promise
end
Promise.Then = Promise.next

--- Sets the error handler for the promise.
---@param fn fun(err: any) The error handler to use
---@return Promise self
function Promise:catch(fn)
    expect(1, fn, "function")
    self.reject = function(err) self.reject = nil fn(err) if self.final then self.final() end end
    return self
end

--- Sets a function to call after the promise settles.
---@param fn fun() The function to call
---@return Promise self
function Promise:finally(fn)
    expect(1, fn, "function")
    self.final = function() self.final = nil return fn() end
    return self
end

---@diagnostic disable: missing-return

---@class PromiseConstructor
local PromiseConstructor = {}

--- Creates a new Promise on the selected run loop.
---@param fn fun(resolve: fun(...: any), reject: fun(err: any)) The main function for the promise
---@return Promise promise The new promise
function PromiseConstructor.new(fn) end

--- Creates a new Promise that resolves once all of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.all(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve, or rejects if all promises reject.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.any(list) end

--- Creates a new Promise that resolves once any of the listed promises resolve.
---@param list Promise[] The promises to wait for
---@return Promise promise The new promise
function PromiseConstructor.race(list) end

--- Creates a new Promise that immediately resolves to a value.
---@param val any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.resolve(val) end

--- Creates a new Promise that immediately rejects with an error.
---@param err any The value to resolve to
---@return Promise promise The new promise
function PromiseConstructor.reject(err) end

--- Makes an HTTP request to a URL, and returns a Promise for the result.
--- The promise will resolve with the handle to the response, which will also
--- have the following methods:
--- - res.text(): Returns a promise that resolves to the body of the response.
--- - res.table(): Returns a promise that resolves to the body unserialized as a Lua table.
--- - res.json(): Returns a promise that resolves to the body unserialized as JSON.
---@param url string The URL to connect to
---@param body? string If specified, a POST body to send
---@param headers? table<string, string> Any HTTP headers to add to the request
---@param binary? boolean Whether to send in binary mode (deprecated as of CC:T 1.109.0)
---@overload fun(options: {url: string, body?: string, headers?: string, method?: string, binary?: string, timeout?: number}): Promise
---@return Promise promise The new promise
function PromiseConstructor.fetch(url, body, headers, binary) end

---@diagnostic enable: missing-return

---@class Taskmaster
---@field Promise PromiseConstructor
local Taskmaster = {}
local Taskmaster_mt = {__name = "Taskmaster", __index = Taskmaster}

--- Adds a task to the loop.
---@param fn fun(Task) The main function to add, which receives the task as an argument
---@return Task task The created task
function Taskmaster:addTask(fn)
    expect(1, fn, "function")
    local task = setmetatable({coro = coroutine.create(fn), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task to the loop in builder style.
---@param fn fun(Task) The main function to add
---@return Taskmaster self
function Taskmaster:task(fn) self:addTask(fn) return self end

--- Adds a function to the loop. This is just like a task, but allows extra arguments.
---@param fn function The main function to add, which receives the arguments passed
---@param ... any Any arguments to pass to the function
---@return Task task The created task
function Taskmaster:addFunction(fn, ...)
    expect(1, fn, "function")
    local args = table.pack(...)
    local task = setmetatable({coro = coroutine.create(function() return fn(table.unpack(args, 1, args.n)) end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a function to the loop in builder style.
---@param fn function The main function to add
---@param ... any Any arguments to pass to the function
---@return Taskmaster self
function Taskmaster:func(fn, ...) self:addFunction(fn, ...) return self end

--- Adds an event listener to the loop. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Task task The created task
function Taskmaster:addEventListener(name, fn)
    expect(1, name, "string")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function() while true do fn(os.pullEvent(name)) end end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds an event listener to the loop in builder style. This is a special task that calls a function whenever an event is triggered.
---@param name string The name of the event to listen for
---@param fn fun(string, ...) The function to call for each event
---@return Taskmaster self
function Taskmaster:eventListener(name, fn) self:addEventListener(name, fn) return self end

--- Adds a task that triggers a function repeatedly after an interval. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Task task The created task
function Taskmaster:addTimer(timeout, fn)
    expect(1, timeout, "number")
    expect(2, fn, "function")
    local task = setmetatable({coro = coroutine.create(function()
        while true do
            sleep(timeout)
            timeout = fn() or timeout
            if timeout <= 0 then return end
        end
    end), master = self, priority = 0}, Task_mt)
    self.new[#self.new+1] = task
    self.shouldSort = true
    return task
end

--- Adds a task that triggers a function repeatedly after an interval in builder style. The function may modify or cancel the interval through a return value.
---@param timeout number The initial interval to run the function after
---@param fn fun():number|nil The function to call.
---If this returns a number, that number replaces the timeout.
---If this returns a number less than or equal to 0, the timer is canceled.
---If this returns nil, the timeout remains the same.
---@return Taskmaster self
function Taskmaster:timer(timeout, fn) self:addTimer(timeout, fn) return self end

--- Sets a blacklist for events to send to all tasks. Tasks can override this with their own blacklist.
---@param list? string[] A list of events to not send to any task
function Taskmaster:setEventBlacklist(list)
    if expect(1, list, "table", "nil") then
        self.blacklist = {}
        for _, v in ipairs(list) do self.blacklist[v] = true end
    else self.blacklist = nil end
end

--- Sets a whitelist for events to send to all tasks. Tasks can override this with their own whitelist.
---@param list? string[] A list of events to send to all tasks (others are discarded)
function Taskmaster:setEventWhitelist(list)
    if expect(1, list, "table", "nil") then
        self.whitelist = {}
        for _, v in ipairs(list) do self.whitelist[v] = true end
    else self.whitelist = nil end
end

--- Sets a function that is used to transform events. This function takes a task
--- and event table, and may modify the event table to adjust the event for that task.
---@param fn fun(Task, table)|nil A function to use to transform events
function Taskmaster:setEventTransformer(fn)
    expect(1, fn, "function", "nil")
    self.transformer = fn
end

--- Sets a function to call before yielding. This can be used to reset state such
--- as terminal cursor position.
---@param fn? fun() The function to call
function Taskmaster:setPreYieldHook(fn)
    expect(1, fn, "function", "nil")
    self.preYieldHook = fn
end

--- Runs the main loop, processing events and running each task.
---@param count? number The number of tasks that can exit before stopping the loop
function Taskmaster:run(count)
    count = expect(1, count, "number", "nil") or math.huge
    self.running = true
    while self.running and (#self.tasks + #self.new) > 0 and count > 0 do
        self.dead = {}
        for i, task in ipairs(self.new) do
            self.currentTask = task
            local old = term.current()
            local ok, filter = coroutine.resume(task.coro, task)
            task.window = term.redirect(old)
            if not ok then
                self.currentTask = nil
                self.running = false
                self.new = {table.unpack(self.new, i + 1)}
                return error(filter, 0)
            end
            task.filter = filter
            if coroutine.status(task.coro) == "dead" then count = count - 1
            else self.tasks[#self.tasks+1], self.shouldSort = task, true end
            if not self.running or count <= 0 then break end
        end
        self.new = {}
        if self.shouldSort then table.sort(self.tasks, function(a, b) return a.priority > b.priority end) self.shouldSort = false end
        if self.running and #self.tasks > 0 and count > 0 then
            if self.preYieldHook then self.preYieldHook() end
            local _ev = table.pack(os.pullEventRaw())
            for i, task in ipairs(self.tasks) do
                local ev = _ev
                if self.transformer then
                    ev = table.pack(table.unpack(_ev, 1, _ev.n))
                    self.transformer(task, ev)
                end
                local wl, bl = task.whitelist or self.whitelist, task.blacklist or self.blacklist
                if not task.paused and
                    (task.filter == nil or task.filter == ev[1] or ev[1] == "terminate") and
                    (not bl or not bl[ev[1]]) and
                    (not wl or wl[ev[1]]) then
                    self.currentTask = task
                    local old = term.redirect(task.window)
                    local ok, filter = coroutine.resume(task.coro, table.unpack(ev, 1, ev.n))
                    task.window = term.redirect(old)
                    if not ok then
                        if task.errh then
                            task.errh(filter, task)
                        else
                            self.currentTask = nil
                            self.running = false
                            table.remove(self.tasks, i)
                            return error(filter, 0)
                        end
                    end
                    task.filter = filter
                    if coroutine.status(task.coro) == "dead" then self.dead[#self.dead+1] = task end
                    if not self.running or #self.dead >= count then break end
                end
            end
        end
        self.currentTask = nil
        for _, task in ipairs(self.dead) do
            for i, v in ipairs(self.tasks) do
                if v == task then
                    table.remove(self.tasks, i)
                    count = count - 1
                    break
                end
            end
        end
    end
    self.running = false
end

--- Runs all tasks until a single task exits.
function Taskmaster:waitForAny() return self:run(1) end
--- Runs all tasks until all tasks exit.
function Taskmaster:waitForAll() return self:run() end

--- Stops the main loop if it is running. This will yield if called from a running task.
function Taskmaster:stop()
    self.running = false
    if self.currentTask then coroutine.yield() end
end

Taskmaster_mt.__call = Taskmaster.run

local function fetch(loop, url, ...)
    local ok, err = http.request(url, ...)
    if not ok then return Promise:_reject(loop, err) end
    return loop.Promise.new(function(resolve, reject)
        while true do
            local event, p1, p2, p3 = os.pullEvent()
            if event == "http_success" and p1 == url then
                p2.text = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        _resolve(data)
                    end)
                end
                p2.json = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserializeJSON(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse JSON") end
                    end)
                end
                p2.table = function()
                    return loop.Promise.new(function(_resolve, _reject)
                        local data = p2.readAll()
                        p2.close()
                        local d = textutils.unserialize(data)
                        if d ~= nil then _resolve(d)
                        else _reject("Failed to parse Lua table") end
                    end)
                end
                return resolve(p2)
            elseif event == "http_failure" and p1 == url then
                if p3 then p3.close() end
                return reject(p2)
            end
        end
    end)
end

--- Creates a new Taskmaster run loop.
---@param ... fun() Any tasks to add to the loop
---@return Taskmaster loop The new Taskmaster
return function(...)
    local loop = setmetatable({tasks = {}, dead = {}, new = {}}, Taskmaster_mt)
    for i, v in ipairs{...} do
        expect(i, v, "function")
        loop:addTask(v)
    end
    loop.Promise = {
        new = function(fn) return Promise:new(loop, fn) end,
        all = function(list) return Promise:all(loop, list) end,
        any = function(list) return Promise:any(loop, list) end,
        race = function(list) return Promise:race(loop, list) end,
        resolve = function(val) return Promise:_resolve(loop, val) end,
        reject = function(err) return Promise:_reject(loop, err) end,
        fetch = function(...) return fetch(loop, ...) end
    }
    setmetatable(loop.Promise, {__call = function(self, ...) return Promise:new(loop, ...) end})
    return loop
end

end
preload["services"] = function(...)
return function(kernProt)
    local ar = require("ar")
    local toml = require("toml")

    local srvsys = {}
    local ldSRV = {}
    local services = {}

    ---@generic service
    local SRVREQ = {
        "load", "unload"
    }

    local function load(srv)
        local s = ar.load("srv/"..srv..".a")
        return s
    end
    local function lookup(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return value
            end
        end
    end
    local function lookupKey(s,name)
        for key, value in pairs(s) do
            if value.name == name then
                return key
            end
        end
    end

    local function onLoad(srv,s)
        --local t = toml.decode(lookup(s,"cfg.toml").data)
        local t = {enabled = true}
        if t.enabled then
            srvsys.run(srv,s)
        end
    end

    local function SRV(t) --- NOT Storm Research Vehicle
        for key, value in pairs(SRVREQ) do
            field(t,value,"function")
        end
        return t
    end

    function srvsys.run(srv,s)
        local d = lookup(s,"srv.lua")
        local task,e = loadstring(d.data,srv)
        assert(task,tostring(task))
        local S = SRV(task(kernProt))
        services[srv] = S
        S.load()
    end

    function srvsys.enable(srv)
        if ldSRV[srv] then
            if services[srv] then
            else
                local s = ldSRV[srv]
                local k =lookupKey(s,"cfg.toml")
                local t = toml.decode(s[k].data)
                t.enabled = true
                s[k].data = toml.encode(t)
                ar.save(s,"srv/"..srv..".a")
                srvsys.run(srv,s)
            end

        end
    end

    function srvsys.load(srv)
        local s = load(srv)
        ldSRV[srv] = s
        --print(lookup(s,"srv.lua").data)
        onLoad(srv,s)
        --TODO
    end

    function srvsys.unload(srv)
        --TODO
    end

    return srvsys
end
end
preload["primeUI"] = function(...)
local expect = require "cc.expect".expect

-- Initialization code
local PrimeUI = {}
do
    local coros = {}
    local restoreCursor

    --- Adds a task to run in the main loop.
    ---@param func function The function to run, usually an `os.pullEvent` loop
    function PrimeUI.addTask(func)
        expect(1, func, "function")
        local t = {coro = coroutine.create(func)}
        coros[#coros+1] = t
        _, t.filter = coroutine.resume(t.coro)
    end

    --- Sends the provided arguments to the run loop, where they will be returned.
    ---@param ... any The parameters to send
    function PrimeUI.resolve(...)
        coroutine.yield(coros, ...)
    end

    --- Clears the screen and resets all components. Do not use any previously
    --- created components after calling this function.
    function PrimeUI.clear()
        -- Reset the screen.
        term.setCursorPos(1, 1)
        term.setCursorBlink(false)
        term.setBackgroundColor(colors.black)
        term.setTextColor(colors.white)
        term.clear()
        -- Reset the task list and cursor restore function.
        coros = {}
        restoreCursor = nil
    end

    --- Sets or clears the window that holds where the cursor should be.
    ---@param win window|nil The window to set as the active window
    function PrimeUI.setCursorWindow(win)
        expect(1, win, "table", "nil")
        restoreCursor = win and win.restoreCursor
    end

    --- Gets the absolute position of a coordinate relative to a window.
    ---@param win window The window to check
    ---@param x number The relative X position of the point
    ---@param y number The relative Y position of the point
    ---@return number x The absolute X position of the window
    ---@return number y The absolute Y position of the window
    function PrimeUI.getWindowPos(win, x, y)
        if win == term then return x, y end
        while win ~= term.native() and win ~= term.current() do
            if not win.getPosition then return x, y end
            local wx, wy = win.getPosition()
            x, y = x + wx - 1, y + wy - 1
            _, win = debug.getupvalue(select(2, debug.getupvalue(win.isColor, 1)), 1) -- gets the parent window through an upvalue
        end
        return x, y
    end

    --- Runs the main loop, returning information on an action.
    ---@return any ... The result of the coroutine that exited
    function PrimeUI.run()
        while true do
            -- Restore the cursor and wait for the next event.
            if restoreCursor then restoreCursor() end
            local ev = table.pack(os.pullEvent())
            -- Run all coroutines.
            for _, v in ipairs(coros) do
                if v.filter == nil or v.filter == ev[1] then
                    -- Resume the coroutine, passing the current event.
                    local res = table.pack(coroutine.resume(v.coro, table.unpack(ev, 1, ev.n)))
                    -- If the call failed, bail out. Coroutines should never exit.
                    if not res[1] then error(res[2], 2) end
                    -- If the coroutine resolved, return its values.
                    if res[2] == coros then return table.unpack(res, 3, res.n) end
                    -- Set the next event filter.
                    v.filter = res[2]
                end
            end
        end
    end
end

--- Draws a line of text at a position.
---@param win window The window to draw on
---@param x number The X position of the left side of the text
---@param y number The Y position of the text
---@param text string The text to draw
---@param fgColor color|nil The color of the text (defaults to white)
---@param bgColor color|nil The color of the background (defaults to black)
function PrimeUI.label(win, x, y, text, fgColor, bgColor)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, text, "string")
    fgColor = expect(5, fgColor, "number", "nil") or colors.white
    bgColor = expect(6, bgColor, "number", "nil") or colors.black
    win.setCursorPos(x, y)
    win.setTextColor(fgColor)
    win.setBackgroundColor(bgColor)
    win.write(text)
end

--- Draws a BIMG-formatted image to the screen. This does not support transparency,
--- and does not handle animation on its own (but the index parameter may be
--- used by apps to implement animation).
---@param win window The window to draw on
---@param x number The X position of the top left corner of the image
---@param y number The Y position of the top left corner of the image
---@param data string|table The path to the image to load, or the image data itself
---@param index number|nil The index of the frame to draw (defaults to 1)
---@param setPalette boolean|nil Whether to set the palette if the image contains one (defaults to true)
function PrimeUI.drawImage(win, x, y, data, index, setPalette)
    expect(1, win, "table")
    expect(2, x, "number")
    expect(3, y, "number")
    expect(4, data, "string", "table")
    index = expect(5, index, "number", "nil") or 1
    expect(6, setPalette, "boolean", "nil")
    if setPalette == nil then setPalette = true end
    -- Load the image file if a string was passed. (This consists of reading the file and unserializing.)
    if type(data) == "string" then
        local file = assert(fs.open(data, "rb"))
        local filedata = file.readAll()
        file.close()
        data = assert(textutils.unserialize(filedata), "File is not a valid BIMG file")
    end
    -- Blit each line to the screen.
    for line = 1, #data[index] do
        win.setCursorPos(x, y + line - 1)
        win.blit(table.unpack(data[index][line]))
    end
    -- Set the palette if one exists and is desired.
    local palette = data[index].palette or data.palette
    if setPalette and palette then
        for i = 0, #palette do
            win.setPaletteColor(2^i, table.unpack(palette[i]))
        end
    end
end

return PrimeUI
end
preload["pfunc"] = function(...)
local pfunc = {}

function pfunc.make()
    local ptbl = {
        private = {},
        protected = {},
        public = {},
    }
    function ptbl:prot()
        return {
            protected = self.protected,
            public = self.public
        }
    end
    return ptbl
end

return pfunc
end
preload["logs"] = function(...)
local log = {}
log.levels = {
    DEBUG    = 1,
    VERBOSE  = 2,
    INFO     = 3,
    NOTICE   = 4,
    WARN     = 5,
    CRITICAL = 6,
}
log.names = {}

for key, value in pairs(log.levels) do
    log.names[value] = key
end

local cols = {
    colors.gray,
    colors.white,
    colors.blue,
    colors.yellow,
    colors.orange,
    colors.red
}
function log.make(id)
    local logger = {}
    function logger.log(lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,"",log.names[lvl]),...)
        term.setTextColor(c)
    end
    function logger.logThrd(thrd,lvl,...)
        local c = term.getTextColor()
        term.setTextColor(cols[lvl])
        print(string.format("[%3s][%6s][%8s]",id,thrd,log.names[lvl]),...)
        term.setTextColor(c)
    end
    return logger
end
return log


end
preload["logo"] = function(...)
-- Generated with sanjuuni
-- https://sanjuuni.madefor.cc
return function()
    local image = {
        {
            "  \159\131 \159\148        ",
            "00ff0f400000000",
            "ff44f4fffffffff"
        },
        {
            "  \129 \148\129\149        ",
            "00f044100000000",
            "ff41f14ffffffff"
        },
        {
            "   \138\149\157\148        ",
            "000144400000000",
            "ff41444ffffffff"
        },
        {
            "  \144\139\144\159\143\129       ",
            "004444770000000",
            "ff4447fffffffff"
        },
        {
            " \130\134\133\136\136\138\133\130  \159\144  ",
            "04444f11100f700",
            "ff4447fffff7fff"
        },
        {
            "  \130\131\139\143\133    \139\143  ",
            "004481700008400",
            "fffffffffffffff"
        }
    }
    
    term.clear()
    for y, r in ipairs(image) do
        term.setCursorPos(1, y)
        term.blit(table.unpack(r))
    end
end
end
preload["kernel"] = function(...)
print("Proot Os")

local pfunc = require("pfunc")

local kernProt = pfunc.make()

TASKS = {}
kernel = kernProt.public

local function SplitFilename(strFilename)
    -- Returns the Path, Filename, and Extension as 3 values
    return string.match(strFilename, "(.-)([^\\]-([^\\%.]+))$")
end

do
    local h = fs.open("/rom/modules/main/cc/expect.lua", "r")
    local f, err = (_VERSION == "Lua 5.1" and loadstring or load)(h.readAll(), "/rom/modules/main/cc/expect.lua")
    h.close()

    if not f then error(err) end
    expect = f()
    field = expect.field
end

require("theme")
local logo = require("logo")
logo()
print()

local log = require("logs")
local syslog = log.make("SYS")
syslog.log(log.levels.DEBUG,"Starting OS...")

kernel.log = {
    syslog = syslog,
    levels = log.levels,
    log = syslog.logThrd
}

local function centerWrite(text)
    local width, height = term.getSize() -- Get terminal size
    local x, y = term.getCursorPos() -- Get current cursor position
    local new_x = math.ceil((width / 2) - (#text / 2))
    term.setCursorPos(new_x, y)
    term.write(text)
end

function kernel.panic(ae)
    term.setBackgroundColor(2)
    term.setTextColor(1)
    term.clear()
    term.setCursorBlink(false)
    term.setCursorPos(1,2)
    local p, q = term.getCursorPos()
    p = 1
    centerWrite("ProotOS")
    q = 3
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

function panic(ae)
    term.setBackgroundColor(32768)
    term.setTextColor(16384)
    term.setCursorBlink(false)
    local p, q = term.getCursorPos()
    p = 1
    local af, ag = term.getSize()
    ae = "panic: " .. (ae or "unknown")
    for ah in ae:gmatch "%S+" do
        if p + #ah >= af then
            p, q = 1, q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
        term.setCursorPos(p, q)
        if p == 1 then term.clearLine() end
        term.write(ah .. " ")
        p = p + #ah + 1
    end
    p, q = 1, q + 1
    if q > ag then
        term.scroll(1)
        q = q - 1
    end
    if debug then
        local ai = debug.traceback(nil, 2)
        for aj in ai:gmatch "[^\n]+" do
            term.setCursorPos(1, q)
            term.write(aj)
            q = q + 1
            if q > ag then
                term.scroll(1)
                q = q - 1
            end
        end
    end
    term.setCursorPos(1, q)
    term.setTextColor(2)
    term.write("panic: We are hanging here...")
    mainThread = nil
    while true do coroutine.yield() end
end

kernProt.private.devs = {}
kernProt.private.drvs = {}

function kernProt.protected.regDrv(name,drv)
    kernProt.private.drvs[name] = drv
    syslog.logThrd("drvsys",log.levels.DEBUG,string.format("loaded driver [%8s]",name))
end

local ofs = fs
dofile("sys/boot/filesystem/init.lua")
syslog.log(log.levels.INFO,"FS Loaded")
fs = filesystem

local taskmaster = require("taskmaster")()

function kernel.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end)
    return Task
end
function kernProt.private.run(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.CRITICAL,"thread",name,"closed")
    end)
    return Task
end
function kernel.runBG(name,func)
    taskmaster:addTask(function(Task)
        TASKS[name] = Task
        xpcall(func,printError,Task)
        TASKS[name] = nil
        syslog.log(log.levels.DEBUG,"thread",name,"closed")
    end):setEventBlacklist {"key", "key_up", "char", "paste", "mouse_click", "mouse_up", "mouse_scroll", "mouse_drag"}
    return Task
end

local srvsys = require("services")(kernProt:prot())

xpcall(function()
    local files = fs.list("srv")
    for i = 1, #files do
        local pth,name,ext = SplitFilename(files[i])
        syslog.logThrd("ld_srv",log.levels.DEBUG,"loading service",name)
        srvsys.load(name)
    end

    srvsys.enable("warp")
end,panic)

syslog.log(log.levels.INFO,"Services started")

kernProt.private.run("kernel",function(Task)
    syslog.log(log.levels.DEBUG,"kernel thread started")
    read()
end)

syslog.log(log.levels.INFO,"Starting Threadding")
taskmaster:run()
read()
kernel.panic("CRITICAL system process died")
end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)

end
preload["ar"] = function(...)
-- Unix ar archive library & program
-- Use in the shell or with require

local function trim(s) return string.match(s, '^()%s*$') and '' or string.match(s, '^%s*(.*%S)') end
local function u2cc(p) return bit.band(p, 0x1) * 8 + bit.band(p, 0x2) + bit.band(p, 0x4) / 4 + 4 end
local function cc2u(p) return bit.band(p, 0x8) / 8 + bit.band(p, 0x2) + bit.band(p, 0x1) * 4 end
local function pad(str, len, c) return string.len(str) < len and string.sub(str, 1, len) .. string.rep(c or " ", len - string.len(str)) or str end
local verbosity = 0

local ar = {}

-- Loads an archive into a table
function ar.load(path)
    if not fs.exists(path) then return nil end
    local file = fs.open(path, "rb")
    local oldread = file.read
    local seek = 0
    file.read = function(c) if c then
        local retval = nil
        if c < 1 then c = 1 end
        if file.seek then retval = oldread(c) else
            for i = 1, c do
                local n = oldread()
                if n == nil then return retval end
                retval = (retval or "") .. string.char(n)
                if (seek + i) % 102400 == 0 then os.queueEvent(os.pullEvent()) end
            end
        end
        seek = seek + c
        return retval
    else return string.char(oldread()) end end
    if file.read(8) ~= "!<arch>\n" then
        file.close()
        error("Not an ar archive", 2)
    end
    local retval = {}
    local name_table = nil
    local name_rep = {}
    os.queueEvent("nosleep")
    while true do
        local data = {}
        local first_c = file.read()
        while first_c == "\n" do first_c = file.read() end
        if first_c == nil then break end
        local name = file.read(15)
        if name == nil then break end
        name = first_c .. name
        if string.find(name, "/") and string.find(name, "/") > 1 then name = string.sub(name, 1, string.find(name, "/") - 1)
        else name = trim(name) end
        data.timestamp = tonumber(trim(file.read(12)))
        data.owner = tonumber(trim(file.read(6)))
        data.group = tonumber(trim(file.read(6)))
        data.mode = tonumber(trim(file.read(8)), 8)
        local size = tonumber(trim(file.read(10)))
        if file.read(2) ~= "`\n" then error("Invalid header for file " .. name, 2) end
        if string.match(name, "^#1/%d+$") then name = file.read(tonumber(string.match(name, "#1/(%d+)"))) 
        elseif string.match(name, "^/%d+$") then if name_table then 
            local n = tonumber(string.match(name, "/(%d+)"))
            name = string.sub(name_table, n+1, string.find(name_table, "\n", n+1) - 1)
        else table.insert(name_rep, name) end end
        data.name = name
        data.data = file.read(size)
        if name == "//" then name_table = data.data
        elseif name ~= "/" and name ~= "/SYM64/" then table.insert(retval, data) end
        os.queueEvent(os.pullEvent())
    end
    file.close()
    if name_table then for k,v in pairs(name_rep) do
        local n = tonumber(string.match(v, "/(%d+)"))
        for l,w in pairs(retval) do if w.name == v then w.name = string.sub(name_table, n, string.find(name_table, "/", n) - 1); break end end
    end end
    return retval
end

-- Writes a table entry to a file
function ar.write(v, p)
    local file = fs.open(p, "wb")
    for s in string.gmatch(v.data, ".") do file.write(string.byte(s)) end
    file.close()
    if fs.setPermissions and v.owner ~= 0 then
        fs.setPermissions(p, v.owner, u2cc(v.mode) + bit.band(v.mode, 0x800) / 0x80)
        fs.setPermissions(p, "*", u2cc(bit.brshift(v.mode, 6)) + bit.band(v.mode, 0x800) / 0x80)
        fs.setOwner(p, v.owner)
    end
    if verbosity > 0 then print("Extracted to " .. p) end
end

-- Extracts files from a table or file to a directory
function ar.extract(data, path)
    if type(data) == "string" then data = ar.load(data) end
    if not fs.exists(path) then fs.makeDir(path) end
    for k,v in pairs(data) do
        local p = fs.combine(path, v.name)
        ar.write(v, p)
    end
end

-- Reads a file into a table entry
function ar.read(p)
    local file = fs.open(p, "rb")
    local retval = {
        name = fs.getName(p),
        timestamp = os.epoch and math.floor(os.epoch("utc") / 1000) or 0, 
        owner = fs.getOwner and fs.getOwner(p) or 0, 
        group = 0,
        mode = fs.getPermissions and cc2u(fs.getPermissions(p, fs.getOwner(p) or 0)) * 0x40 + cc2u(fs.getPermissions(p, "*")) + bit.band(fs.getPermissions(p, "*"), 0x10) * 0x80 or 0x1FF,
        data = ""
    }
    if file.seek then retval.data = file.read(fs.getSize(p)) else
        local c = file.read()
        while c ~= nil do 
            retval.data = retval.data .. string.char(c)
            c = file.read()
        end
    end
    file.close()
    return retval
end

-- Packs files in a directory into a table (skips subdirectories)
function ar.pack(path)
    local retval = {}
    for k,v in pairs(fs.list(path)) do
        local p = fs.combine(path, v)
        if not fs.isDir(p) then retval[v] = ar.read(p) end
    end
    return retval
end

-- Saves a table to an archive file
function ar.save(data, path)
    local file = fs.open(path, "wb")
    local oldwrite = file.write
    local seek = 0
    file.write = function(str) 
        for c in string.gmatch(str, ".") do oldwrite(string.byte(c)) end
        seek = seek + string.len(str)
    end
    file.write("!<arch>\n")
    local name_table = {}
    local name_str = nil
    for k,v in pairs(data) do if string.len(v.name) > 15 then 
        name_table[v.name] = string.len(name_str or "")
        name_str = (name_str or "") .. v.name .. "\n"
    end end
    if name_str then
        file.write("//" .. string.rep(" ", 46) .. pad(tostring(string.len(name_str)), 10) .. "`\n" .. name_str)
        if seek / 2 == 1 then file.write("\n") end
    end
    for k,v in pairs(data) do
        local name = name_table[v.name] and "/" .. name_table[v.name] or v.name .. (name_str and "/" or "")
        file.write(pad(name, 16) .. pad(tostring(v.timestamp), 12) .. pad(tostring(v.owner), 6) .. pad(tostring(v.group), 6))
        file.write(pad(string.format("%o", v.mode), 8) .. pad(tostring(string.len(v.data)), 10) .. "`\n" .. v.data)
        if seek % 2 == 1 then file.write("\n") end
    end
    file.close()
    os.queueEvent("nosleep")
    os.pullEvent()
end

local function strmap(num, str, c)
    local retval = ""
    for i = 1, string.len(str) do retval = retval .. (bit.band(num, bit.blshift(1, string.len(str)-i)) == 0 and c or string.sub(str, i, i)) end
    return retval
end

local function CurrentDate(z)
    local z = math.floor(z / 86400) + 719468
    local era = math.floor(z / 146097)
    local doe = math.floor(z - era * 146097)
    local yoe = math.floor((doe - doe / 1460 + doe / 36524 - doe / 146096) / 365)
    local y = math.floor(yoe + era * 400)
    local doy = doe - math.floor((365 * yoe + yoe / 4 - yoe / 100))
    local mp = math.floor((5 * doy + 2) / 153)
    local d = math.ceil(doy - (153 * mp + 2) / 5 + 1)
    local m = math.floor(mp + (mp < 10 and 3 or -9))
    return y + (m <= 2 and 1 or 0), m, d
end
    
local function CurrentTime(unixTime)
    local hours = math.floor(unixTime / 3600 % 24)
    local minutes = math.floor(unixTime / 60 % 60)
    local seconds = math.floor(unixTime % 60)
    local year, month, day = CurrentDate(unixTime)
    return {
        year = year,
        month = month,
        day = day,
        hours = hours,
        minutes = minutes < 10 and "0" .. minutes or minutes,
        seconds = seconds < 10 and "0" .. seconds or seconds
    }
end

local months = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}

if pcall(require, "ar") then
    local args = {...}
    if #args < 2 then error("Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]") end
    if args[1] == "--version" then
        print("CraftOS ar (CCKernel2 binutils) 1.0 (compatible with GNU/BSD ar)\nCopyright (c) 2019-2020 JackMacWindows.")
        return 2
    end
    local mode = nil
    local update = false
    local truncate = false
    if string.find(args[1], "d") then mode = 0 end -- delete
    if string.find(args[1], "p") then mode = 1 end -- print file
    if string.find(args[1], "q") then mode = 2 end -- quick append
    if string.find(args[1], "r") then mode = 3 end -- replace or add
    if string.find(args[1], "t") then mode = 4 end -- list
    if string.find(args[1], "x") then mode = 5 end -- extract
    if string.find(args[1], "c") then verbosity = -1 end
    if string.find(args[1], "v") then verbosity = 1 end
    if string.find(args[1], "u") then update = true end
    if string.find(args[1], "T") then truncate = true end
    if string.find(args[1], "f") then truncate = true end
    local data = ar.load(shell.resolve(args[2]))
    local files = {...}
    table.remove(files, 1)
    table.remove(files, 1)
    if data == nil then
        if verbosity > -1 then print("ar: Creating archive " .. shell.resolve(args[2])) end
        data = {}
    end
    if mode == 0 then
        for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then data[k] = nil; break end end end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 1 then
        if #args > 2 then for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then print(v.data); break end end end
        else for k,v in pairs(data) do print(v.data) end end
    elseif mode == 2 then
        for k,v in pairs(files) do 
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            table.insert(data, f) 
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 3 then
        for k,v in pairs(files) do
            local f = ar.read(shell.resolve(v))
            f.name = string.sub(f.name, 1, truncate and 15 or nil)
            local found = false
            for l,w in pairs(data) do if w.name == f.name then
                found = true
                for m,x in pairs(f) do w[m] = f[m] end
                break
            end end
            if not found then table.insert(data, f) end
        end
        ar.save(data, shell.resolve(args[2]))
    elseif mode == 4 then
        if verbosity > 0 then
            local tmp = {}
            local max = {0, 0, 0, 0, 0}
            for k,v in pairs(data) do
                local date = CurrentTime(v.timestamp)
                local d = months[date.month] .. " " .. date.day .. " " .. date.hours .. ":" .. date.minutes .. " " .. date.year
                local p = {strmap(v.mode, "rwxrwxrwx", "-"), v.owner .. "/" .. v.group, string.len(v.data), d, v.name}
                for l,w in pairs(p) do if string.len(w) + 3 > max[l] then max[l] = string.len(w) + 3 end end
                table.insert(tmp, p)
            end
            for k,v in pairs(tmp) do
                for l,w in pairs(v) do write(pad(w, max[l])) end
                print("")   
            end
        else for k,v in pairs(data) do print(v.name) end end
    elseif mode == 5 then
        local path = #files > 0 and table.remove(files, 1) or "."
        local f
        if #files > 0 then
            f = {}
            for k,v in pairs(data) do for l,w in pairs(files) do if v.name == w then table.insert(f, v); break end end end
        else f = data end
        ar.extract(f, shell.resolve(path))
    else error("Unknown mode") end
end

return ar
end
preload["Howlfile"] = function(...)
Options:Default "trace"

Tasks:clean()

Tasks:minify "minify" {
	input = "/bin/kernel.lua",
	output = "/bin/kernel.min.lua",
}

Tasks:require "main" {
	include = "*.lua",
	startup = "kernel.lua",
	output = "/bin/kernel.lua",
}

Tasks:Task "build" { "clean", "minify" } :Description "Main build task"


Tasks:Default "main"
end
return preload["kernel"](...)
